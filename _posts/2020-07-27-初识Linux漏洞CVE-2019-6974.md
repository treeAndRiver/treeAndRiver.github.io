---
layout:     post
title:      初识Linux漏洞--CVE-2019-6974
subtitle:   
date:       2020-07-27
author:     ZX
header-img: img/post-bg-universe.jpg
catalog: true
tags:
    - vulnerability
    - UAF
    - race condition
---



# 初识Linux（C语言）漏洞

## 有哪些漏洞类型

![编程语言安全性排行榜：Ruby最佳，C语言漏洞最多？](https://static.geekbang.org/infoq/5c947cb8b836b.png?imageView2/0/w/800)

​																																												ps: [图源链接](https://www.infoq.cn/article/VMQhWL6eH9-CRm4a7zkY)

比如CVE-2019-6974漏洞就是属于Use After Free.

补充：CWE——Common Weakness Enumeration，通用缺陷列表。它由一个开源社区维持，该社区有理解软件中的瑕疵并创作对自动化工具去识别、修复并防止这些瑕疵的愿景；

​			CVE——Common Vulnerabilities and Exposures，常见漏洞披露。是一个与信息安全有关的数据库，收集各种信息安全弱点及漏洞并给予编号以便于公众查阅。

## CVE-2019-6974

1、

> kvm_ioctl_create_device() contains the following code: **（有漏洞的源代码）**
>
> ```c
> static int kvm_ioctl_create_device(struct kvm *kvm, struct kvm_create_device *cd)
> {
>   //省略部分代码
>  
> 	 dev = kzalloc(sizeof(*dev), GFP_KERNEL);
>   	 if (!dev)
>           return -ENOMEM;
> 
> ​        dev->ops = ops;
> ​        dev->kvm = kvm; //1. creates a device that holds a reference to the VM object 我怎么知道这里的kvm是没有引用计数的？或者说kvm是栈内存还是堆内存？答：像这种结构体都是：栈上的指针指向存在堆上的结构体，具体的kvm查看定义源码可以发现其拥有一个引用计数的成员，当然就有引用计数。另外，引用计数是需要程序员手动增减的。
> 
> ​        mutex_lock(&kvm->lock); //2. initializes the device
> ​        ret = ops->create(dev, cd->type);
> ​        if (ret < 0) {
> ​                mutex_unlock(&kvm->lock);
> ​                kfree(dev);
> ​                return ret;
> ​        }
> ​        list_add(&dev->vm_node, &kvm->devices);
> ​        mutex_unlock(&kvm->lock);
> 
> ​        if (ops->init)
> ​                ops->init(dev);
> 
>       //3. transfers the reference to the device to the caller's file descriptor table
>       //这个函数把dev的一个引用传给了文件描述符对应的file结构体的一个成员，却没有将dev的引用计数加1，如果一个子线程（子线程会共享文件描述符表，且已经拥有了对应的file 结构体，refcount不会加1，然后可以直接关闭导致refcount减1）刚好在此函数后（小窗口期）将此文件描述符关闭，导致file结构体引用计数减1被释放，从而dev引用计数减1被释放，从而kvm引用计数减1为0。——更具体可以去看proc（见下面给出的引用链接。复现代码里面：创建子线程直接调用close(fd))。
> ​        ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);
> ​        if (ret < 0) {
> ​                mutex_lock(&kvm->lock);
> ​                list_del(&dev->vm_node);
> ​                mutex_unlock(&kvm->lock);
> ​                ops->destroy(dev);
> ​                return ret;
> ​        }
> 
> ​        kvm_get_kvm(kvm); //4. turn the borrowed reference to the VM into a real reference
> ​        cd->fd = ret;
>  	 return 0;
> }
> ```
>
> This code:
>
> 1. creates a device that holds a reference to the VM object (with a borrowed
>    reference, the VM's refcount has not been bumped yet)
>
> 2. initializes the device
>
> 3. transfers the reference to the device to the caller's file descriptor table
>
> 4. calls kvm_get_kvm() to turn the borrowed reference to the VM into a real
>    reference
>
> The ownership transfer in step 3 must not happen before the reference to the VM
> becomes a proper, non-borrowed reference, which only happens in step 4.
> After step 3, an attacker can close the file descriptor and drop the borrowed
> reference, which can cause the refcount of the kvm object to drop to zero.
>
> [引用链接](https://bugs.chromium.org/p/project-zero/issues/detail?id=1765)
>
> **修改之后的代码：**
>
> ```C
> if (ops->init)
> 		ops->init(dev);
> 
> ++	kvm_get_kvm(kvm);
> 	ret = anon_inode_getfd(ops->name, &kvm_device_fops, dev, O_RDWR | O_CLOEXEC);
> 	if (ret < 0) {
> ++		kvm_put_kvm_no_destroy(kvm);
> 		mutex_lock(&kvm->lock);
> 		list_del(&dev->vm_node);
> 		mutex_unlock(&kvm->lock);
> 		ops->destroy(dev);
> 		return ret;
> 	}
> --  kvm_get_kvm(kvm);
> 	cd->fd = ret;
> 	return 0;
> ```
>
> 

## Linux内核知识补充

### 线程与进程

1、fork——生成子进程；clone——生成子线程；创建子进程，则对应打开的file结构体refcount加1；创建子线程，则refcount不会加1。

------

## C语言知识补充

1、函数参数传递方式：值传递 和 引用传递。C语言里面只有值传递，C++两种都有。

2、

> 在C语言开发中，内存分配有3种方式：一是在栈上创建，由编译器自动分配释放，存放函数的参数值、函数体内的局部变量等。如void fun（）{int a；……}，变量a在函数fun（）执行结束时会自动释放。二是静态存储区域分配。如static int x=1；变量x为静态变量，生存期较长，从第1次使用就始终存在，直到整个程序结束时自动释放。三是动态内存分配，在堆上分配，通过malloc或calloc申请，通过free释放。

3、C语言内存管理 [很好的文章](https://casatwy.com/ccheng-xu-de-nei-cun-guan-li.html)。

> 一般情况下，程序中都会有栈内存和堆内存混合使用，当函数在使用指针类的形参时，因为难以区分这个指针对应的内存是栈内存还是堆内存，因此就很难采取正确的内存管理措施。

4、堆栈内存举例：

> **举例1：** 
> `void f() { int* p=new int[5]; }` 
> 这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存的指针p。

> **举例2：**
>
> 栈内存分配 ：
> —————-------------------------------------------------- 
> char*  AllocStrFromStack() 
> { 
> char pstr[100]; 
> return pstr; 
> } 
>
> 堆内存分配 ：
> —————--------------------------------------------------
>
> char*  AllocStrFromHeap(int len) 
> { 
> char *pstr; 
>
> if ( len <= 0 ) return NULL; 
> return ( char* ) malloc( len ); 
> } 
>
> 对于第一个函数，那块pstr的内存在函数返回时就被系统释放了。于是所返回的char*什么也没有。而对于第二个函数，是从堆上分配内存，所以哪怕是程序退出时，也不释放，所以第二个函数的返回的内存没有问题，可以被使用。但一定要调用free释放，不然就是Memory Leak！ 

